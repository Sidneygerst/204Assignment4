---
title: "Assignment 4"
author: "Sidney Gerst, Natalie Dornan"
date: "May 30, 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r include = FALSE}

#load packages
library(tidyverse)
library(janitor)
library(stargazer)

#load and tidy the data

hw4 <- read_csv("HW4Data.csv") %>%
  clean_names()

#abatement is quantity. the reduction from current carbon emissions


```

###1. Marginal Cost of Abatement

####Sector A
```{r include = FALSE, message= FALSE}

#Regression analysis for Sector A(how does the data look graphically?)
plot_a <- ggplot(hw4, aes(x = abatement, y = mc_a)) +
  geom_point() +
  geom_smooth()

plot_a #looks very linear

#bc the data looks linear, use a linear regression

lm_a <- lm(mc_a ~ abatement, data = hw4)

lm_a
# Coefficients:
# (Intercept)    abatement  
#     -8.6445       0.5768 

#store the coefficients 

int_a <- lm_a$coefficients[1]
slope_a <- lm_a$coefficients[2]


```

<br>
$Marginal~Cost~of~Abatement~Sector~A = `r slope_a`*q + `r int_a`$

<br>

####Sector B 
```{r include = FALSE, message= FALSE}

#Regression analysis for Sector B(how does the data look graphically?)
plot_b <- ggplot(hw4, aes(x = abatement, y = mc_b)) +
  geom_point() +
  geom_smooth()

plot_b #looks very logistic, but sam is going to use a linear model so we will as well !

#if we really want to we can use a logit regression LATER

lm_b <- lm(mc_b ~ abatement, data = hw4)

lm_b
# Coefficients:
# (Intercept)    abatement  
#      9.3177       0.1987 

#store the coefficients 

int_b <- lm_b$coefficients[1]
slope_b <- lm_b$coefficients[2]


```

<br>
$Marginal~Cost~of~Abatement~Sector~B = `r slope_b`*q + `r int_b`$

<br>

####Sector C
```{r include= FALSE, message= FALSE}

#Regression analysis for Sector B(how does the data look graphically?)
plot_c <- ggplot(hw4, aes(x = abatement, y = mc_c)) +
  geom_point() +
  geom_smooth()

plot_c #looks very exponetial, but again, Sam said he was going to use lineal for all to make it easier on us later



lm_c <- lm(mc_c ~ abatement, data = hw4)

lm_c
# Coefficients:
# (Intercept)    abatement  
#    -11.6550       0.7838 

#store the coefficients 

int_c <- lm_c$coefficients[1]
slope_c <- lm_c$coefficients[2]



```

<br>
$Marginal~Cost~of~Abatement~Sector~C = `r slope_c`*q + `r int_c`$

<br>

####Sector D
```{r include=FALSE, message=FALSE}

#Regression analysis for Sector B(how does the data look graphically?)
plot_d <- ggplot(hw4, aes(x = abatement, y = mc_d)) +
  geom_point() +
  geom_smooth()

plot_d #looks very exponetial, but again, Sam said he was going to use lineal for all to make it easier on us later



lm_d <- lm(mc_d ~ abatement, data = hw4)

lm_d
# Coefficients:
# (Intercept)    abatement  
#      9.6875       0.2599  

#store the coefficients 

int_d <- lm_d$coefficients[1]
slope_d <- lm_d$coefficients[2]


```

<br>
$Marginal~Cost~of~Abatement~Sector~D = `r slope_d`*q + `r int_c`$

<br>

####Table of the regression coefficients 
```{r echo = FALSE, results = 'asis'}
#Stargazer table for the regressions

mc_table <- stargazer(lm_a, lm_b, lm_c, lm_d,
                          type = 'html', 
                          #single.row = TRUE,
                          align = TRUE,
                          title = "Table 1. Marginal abatement cost function for each sector.",
                          dep.var.labels = c("A", "B","C","D"), 
                          covariate.labels = c("Abatement", "Constant"),
                          add.lines = list(c("AIC", round(AIC(lm_a),1), round(AIC(lm_b),1), round(AIC(lm_c),1), round(AIC(lm_d),1))))


```

<br>
 
####Plot all Abatement Curves 
```{r echo=FALSE, message=FALSE}

# gather df so graphing is easier
# Marginal Abatement Cost dataframe
mac_df <- gather(hw4, key = "sector", value = "marginal_cost", "mc_a", "mc_b", "mc_c", "mc_d")



# graph it!
# can change line/point colors if we want
cols <- c("mc_a" = "hotpink1", "mc_b" = "royalblue1", "mc_c" = "seagreen3", "mc_d" = "coral1")
labels <- c("mc_a" = "A", "mc_b" = "B", "mc_c" = "C", "mc_d" = "D")


all_curves <- ggplot(mac_df, aes(x = abatement, y = marginal_cost)) +
  geom_point(aes(color = sector)) +
  geom_smooth(aes(color = sector), se = FALSE, method = lm) +
#  facet_grid(~sector) +
  scale_color_manual(values = cols,
                     labels = labels,
                     name = "Sector") + 
  theme_classic() + 
  labs(x = "Carbon Abatement (tons)", y = "Abatement Cost ($/ton)")
all_curves


#need to figure out how to plot multiple regressions onto one plot
# no <- qplot(x=mc_d, y=abatement, data=hw4)+
#   geom_abline(aes(intercept=int_a, slope=slope_a, col = "red"), data=lm_a) +
#   geom_abline(aes(intercept = int_b, slope=slope_b, col = "green"), data= lm_b) +
#   geom_abline(aes(intercept = int_c, slope = slope_c, col = "blue"), data= lm_c) +
#   geom_abline(aes(intercept = int_d, slope = slope_d, col = "yellow"), data = lm_d) +
#   theme_bw()
# 
# no


```




###2. Demand Curves of carbon emissions

<br>

#####Sector A
```{r include=FALSE}

#emissions for sector A are 180. we need to make a sequence from 0-180 by 10
quant_a <- seq(0,180,by=10)


#create a function for sector A demand curve 

demand_a <- function(q){
  (slope_a*(180-q)) + int_a
}

# Derive demand curve using the values above
d_a <- demand_a(quant_a)

#willing to pay 95.2 for the first ton of emissions 

# Graph it to see if this worked....
curve(demand_a, from=0, to=180, xlab = "x", ylab = "y")


```

 
Plugging in 0 for q will result in the willingness to pay for the right to pollute the first unit.
Sector A:  $Price~of~Emissions = `r slope_a`*(180-q) + `r int_a`$  
$Willingness~to~Pay~for~First~Unit = \$95.2$ 

<br>

#####Sector B
```{r include = FALSE }
#emissions for sector A are 180. we need to make a sequence from 0-180 by 10
quant_b <- seq(0,200,by=10)


#create a function for sector A demand curve 

demand_b <- function(q){
  (slope_b*(200-q)) + int_b
}

# Derive demand curve using the values above
d_b <- demand_b(quant_b)

#willing to pay 95.2 for the first ton of emissions 

# Graph it to see if this worked....
curve(demand_b, from=0, to=200, xlab = "x", ylab = "y")
```

  
$Price~of~Emissions = `r slope_b`*(180-q) + `r int_b`$  
$Willingness~to~Pay~for~First~Unit = \$49.1$ 

<br>

#####Sector C
```{r include = FALSE}
#emissions for sector A are 180. we need to make a sequence from 0-180 by 10
quant_c <- seq(0,220,by=10)


#create a function for sector A demand curve 

demand_c <- function(q){
  (slope_c*(220-q)) + int_c}

# Derive demand curve using the values above
d_c <- demand_c(quant_c)

#willing to pay 95.2 for the first ton of emissions 

# Graph it to see if this worked....
curve(demand_c, from=0, to=220, xlab = "x", ylab = "y")
```

$Price~of~Emissions = `r slope_c`*(180-q) + `r int_c`$  
$Willingness~to~Pay~for~First~Unit = \$161$ 

<br>

#####Sector D
```{r include = FALSE }
#emissions for sector A are 180. we need to make a sequence from 0-180 by 10
quant_d <- seq(0,300,by=10)


#create a function for sector A demand curve 

demand_d <- function(q){
  (slope_d*(300-q)) + int_d
}

# Derive demand curve using the values above
d_d <- demand_d(quant_d)

#willing to pay 95.2 for the first ton of emissions 

# Graph it to see if this worked....
curve(demand_d, from=0, to=300, xlab = "x", ylab = "y")

```

$Price~of~Emissions = `r slope_d`*(180-q) + `r int_d`$  
$Willingness~to~Pay~for~First~Unit = \$87.7$

<br>

####Combined Demand Curves
```{r echo = FALSE, warning=FALSE}

#Plot the demands on the same chart
#"mc_a" = "hotpink1", "mc_b" = "royalblue1", "mc_c" = "seagreen3", "mc_d" = "coral1"
cols_demand <- c("hotpink1", "royalblue1", "seagreen3", "coral1")
labels_demand <- c("A", "B", "C", "D")
demand_graph <- ggplot(data.frame(x=c(0,350)), aes(x=x)) + # data.frame gives ggplot something to graph
  stat_function(fun=demand_a, geom = "line", aes(color = "A"), size = 1) +
  stat_function(fun=demand_b, geom = "line", aes(color = "B"), size = 1) +
  stat_function(fun=demand_c, geom = "line", aes(color = "C"), size = 1) +
  stat_function(fun=demand_d, geom = "line", aes(color = "D"), size = 1) +
  scale_y_continuous(limits= c(0,175), expand = c(0,0)) +
  scale_x_continuous(limits= c(0, 400), expand = c(0,0)) +
  scale_color_manual(values = cols_demand,
                     labels = labels_demand,
                     name = "Sector") + 
  theme_classic() + 
  labs(x = "Carbon Abatement (tons)", y = "Abatement Cost ($/ton)")

demand_graph


```


<br> 

###3. Country X

#####A. Cap on Carbon. 
```{r include = FALSE}

#aggregate the costs of A, B, and C
#create functions of individual cost curves
lm_func_a <- function(q){
  slope_a*q + int_a
}



lm_func_b <- function(q){
  slope_b*q +int_b
}

lm_func_c <- function(q){
  slope_c*q + int_c
}

countryx <- function(q){
  
  lm_func_a(q) + lm_func_b(q) + lm_func_c(q)
  
}

curve(countryx, from=0, to=600, xlab = "x", ylab = "y")


####QUESTION: Do we just cut the aggregate cost curve by 100? 

#QUESTION: Do we just cut the aggregate cost curve by 100? 
#is the price at 300 above the intercept for any of the sectors?


```



```{r echo = FALSE }
#THIS IS THE AGGREGATE COST OF ABATEMENT  

#aggregate horizontally
slope_x = slope_a * slope_b + slope_a * slope_c + slope_b * slope_c
agg_y_int_x = (int_a*slope_b*slope_c/slope_x) + (int_b*slope_a*slope_c/slope_x) + (int_c*slope_b*slope_a/slope_x)
agg_coeff_x = (slope_a*slope_b*slope_c/slope_x)


#create the aggregate function
agg_abate_x <- function(q){
  agg_coeff_x*q + agg_y_int_x
}


#integratethe lm functions to find the total cost of a cap on carbon

costA_X <- integrate(lm_func_a, 0, 100)$value
costB_X <- integrate(lm_func_b, 0, 100)$value
costC_X <- integrate(lm_func_c, 0, 100)$value
cost_total <- costA_X + costB_X + costC_X






```


1. Total Cost of Carbon Cap   

$Total~Cost = `r round(cost_total, digits=2)`$   

2. Cost to each Sector 

$Cost~to~Sector~A = `r round(costA_X, digits=2)`$    

$Cost~to~Sector~B = `r round(costB_X, digits=2)`$    

$Cost~to~Sector~C = `r round(costC_X, digits=2)`$ 

3. There is no tax revenue with a cap on carbon

<br>

#####B. Tax on Carbon
```{r echo = FALSE }

#find the price at 300 tons of abatement for each sector 
tax_price <- agg_abate_x(300) #$39.4 

unit_A <- (tax_price - int_a)/slope_a # 83.3
unit_B <- (tax_price - int_b)/slope_b # 151
unit_C <- (tax_price - int_c)/slope_c # 65.2

#solve the benefit for b, tax for carbon
costtax_A_X <- integrate(lm_func_a, 0, unit_A)$value
costtax_B_X <- integrate(lm_func_b, 0, unit_B)$value
costtax_C_X <- integrate(lm_func_c, 0, unit_C)$value
costtax_total <- costtax_A_X + costtax_B_X + costtax_C_X
tax_revenue_X <- 300*tax_price


```


1. Total Cost of Carbon Tax   

$Total~Cost = `r round(costtax_total, digits=2)`$   

2. Cost to each Sector 

$Cost~to~Sector~A = `r round(costtax_A_X, digits=2)`$    

$Cost~to~Sector~B = `r round(costtax_B_X, digits=2)`$    

$Cost~to~Sector~C = `r round(costtax_C_X, digits=2)`$ 

3. Total Tax Revenue

$Total~Tax~Revenue = `r round(tax_revenue_X, digits=2)`$

<br>

#####C. Cap and Trade
```{r echo = FALSE }





```

1. Total Cost of Carbon Cap and Trade

2. Cost to each sector 

3. Total Tax Revenue. Not applicable, no tax in Cap and Trade.